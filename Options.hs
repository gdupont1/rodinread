module Options where

import Control.Monad
import Control.Monad.Trans.Class
import Data.List.Split (splitOn)
import Data.List (intercalate)

import TeX
import Ascii
import Substitution
import RodinTheory (Theory)
import RodinTheory.Read
import RodinTheory.TeX
import RodinTheory.Ascii
import RodinTheory.Substitution
import RodinContext (Context)
import RodinContext.Read
import RodinContext.TeX
import RodinContext.Ascii
import RodinContext.Substitution
import RodinMachine (Machine)
import RodinMachine.Read
import RodinMachine.TeX
import RodinMachine.Ascii
import RodinMachine.Substitution
import RodinPO (POFile)
import RodinPO.Read
import RodinPO.TeX
import RodinPO.Ascii
import RodinPO.Substitution

-- | Define a type as being "parsable"
-- This serves as a wrapper for defining parser configurations.
-- To properly add a parser, one should first create a new constructor in the Parsed data type,
-- then instanciate the resulting structure of its parser as being parsable.
class Parsable a where
  toParsed :: a -> Parsed

-- | A Context is parsable
instance Parsable Context where
  toParsed = PContext

-- | A Machine is parsable
instance Parsable Machine where
  toParsed = PMachine

-- | A Theory is parsable
instance Parsable Theory where
  toParsed = PTheory

-- | Proof Obligation file is parsable
instance Parsable POFile where
  toParsed = PPOFile

-- | Parsed data type, effectively wrapping the structures resulting from parsing.
-- When adding a parser, one should also add a constructor to this type that wraps her new structure.
data Parsed =
      PContext Context
    | PMachine Machine
    | PTheory  Theory
    | PPOFile  POFile

-- | Parsed can be ShowTeX; it comes from the fact that the objects in its constructors are effectively ShowTeX
-- If one want to be able to export its parsed structure to TeX, it should add the relevant line
instance ShowTeX Parsed where
  showTeX (PContext ct) = showTeX ct
  showTeX (PMachine ma) = showTeX ma
  showTeX (PTheory  th) = showTeX th
  showTeX (PPOFile  po) = showTeX po

-- | Same thing as for ShowTeX but for ASCII
instance ShowAscii Parsed where
  showAscii (PContext ct) = showAscii ct
  showAscii (PMachine ma) = showAscii ma
  showAscii (PTheory  th) = showAscii th
  showAscii (PPOFile  po) = showAscii po

-- | Similar mechanism for Substituable
instance Substituable Parsed where
  substitute st (PContext ct) = PContext <$> substitute st ct
  substitute st (PMachine ma) = PMachine <$> substitute st ma
  substitute st (PTheory  th) = PTheory  <$> substitute st th
  substitute st (PPOFile  po) = PPOFile  <$> substitute st po

-- | Create a parser for a parsable object based on its actual parser.
-- This will basically take any parser of the form String -> IO a to a parser of the form String -> IO Parsed (effectively doing the wrapping).
mkParser :: Parsable a => (String -> IO a) -> (String -> IO Parsed)
mkParser parser =
    \x -> parser x >>= (return . toParsed)

-- | A read (or parsing) configuration.
data ReadConfig = ReadConfig {
    readerName :: String,               -- ^ Name of the parser (for pretty printing)
    processor  :: String -> IO Parsed   -- ^ The parsing function
}

-- | List of possible reading configurations as a (<file extension>,<reading configuration>) list
-- When adding a new parser, one should extend this table with correct informations.
readConfTable :: [(String,ReadConfig)]
readConfTable =
    [ ("buc",ReadConfig "context"           $ mkParser parseContextFile)
    , ("bum",ReadConfig "machine"           $ mkParser parseMachineFile)
    , ("tuf",ReadConfig "theory"            $ mkParser parseTheoryFile )
    , ("bpo",ReadConfig "proof obligations" $ mkParser parsePOFileFile) ]

-- | A write configuration
data WriteConfig = WriteConfig {
    writerName :: String,           -- ^ Writer name (for pretty printing)
    writerExtension :: String,      -- ^ File extension for the files generated by the writer
    stringify :: Parsed -> String   -- ^ Function turning a Parsed object to a proper string
}

-- | Retrieve file base name (i.e. without prefix path)
basename :: String -> String
basename = last . (splitOn "/")

-- | Change the directory of a file
setDir :: String -> String -> String
setDir "" s = s
setDir od s = od ++ (if last od == '/' then "" else "/") ++ (basename s)

writeOut :: WriteConfig -> String -> String -> Parsed -> IO ()
writeOut conf filename outdir parsed =
    writeFile newfile $ stringify conf parsed
    where newfile = (setDir outdir filename) ++ "." ++ writerExtension conf



-- | List of possible writing configurations as a (<file extension>,<writing configuration>) list
-- If one wants to add a new writer, it should create a typeclass for it and instanciate it for the various parsed structures.
-- It should then instanciate it for the Parsed type and add it to this table.
writeConfTable :: [(String,WriteConfig)]
writeConfTable = 
    [ (  "tex",WriteConfig "TeX"   "tex"   (showTeX))
    , ("ascii",WriteConfig "ASCII" "ascii" (showAscii)) ]

-- | Default writing configuration (TeX)
defaultWriteConfig :: WriteConfig
defaultWriteConfig = WriteConfig "TeX" "tex" showTeX

-- | Read substitutions of command line
readSubstitutions :: [String] -> STWrapT IO SubstitutionTable
readSubstitutions substs = do
    st  <- foldl fmreduce (return emptySubstitutionTable) substs
    lift (putStrLn "Checking for incoherence...")
    st' <- detectcollisions st
    lift (putStrLn "Substitution processing done!")
    return st'
    where fmreduce :: STWrapT IO SubstitutionTable -> String -> STWrapT IO SubstitutionTable
          fmreduce acc fn = do
              lift (putStrLn $ "Parsing substitution file " ++ fn ++ "...")
              (liftM2 union) acc $ fromFile fn
          detectcollisions :: SubstitutionTable -> STWrapT IO SubstitutionTable
          detectcollisions st = do
              case collisions st of
                [] -> return st
                cs -> WrapT $ return $ failwith' 0 "" $ "collisions found in merged substitution table!\n" ++ showCollisions cs
          showCollisions collisions =
              foldl showCollision [] $ zip [1..] collisions
          showCollision acc (i,rules) =
              acc ++ ("\nCollision " ++ show i ++":") ++ (foldl showRule [] rules)
          showRule acc r =
              acc ++ "\n - " ++ show r

-- | Type for result of the command line reading
data Option =
      Error [String]  -- ^ Command line is inconsistent and raised an error
    | Help            -- ^ Command line asks for help
    | Cmd Command     -- ^ Command line parses to some options
    | NoOption        -- ^ Nothing on the command line

-- | Structure for holding the command line arguments
data Command = Command {
    writeconf :: WriteConfig,              -- ^ Writing configuration (e.g. TeX, ASCII)
    readconfs :: [(String,ReadConfig)],    -- ^ Reading configuration as a pair of file-readconfig
    outputdir :: String,                   -- ^ Output directory
    substitutionFiles :: [String]          -- ^ List of substitution files
}

-- | Default command for building actual commands upon
defaultCommand :: Command
defaultCommand = Command defaultWriteConfig [] "" []

-- | Kind of monadic following (>>) for options (easier to read)
infixl 1 `cue`
cue :: Option -> Option -> Option
cue NoOption x = x
cue x NoOption = x
cue Help _ = Help
cue _ Help = Help
cue (Error e1) (Error e2) = Error $ e2 ++ e1
cue e@(Error _) _ = e
cue _ e@(Error _) = e
cue (Cmd c1) c@(Cmd c2) = c

-- | Kind of monadic composition (>>=) for options (easier to read)
infixl 1 `chain`
chain :: Option -> (Command -> Option) -> Option
chain NoOption f = f defaultCommand
chain Help _ = Help
chain e@(Error _) _ = e
chain (Cmd c1) f = f c1

-- | Read the argument options and return either a Nothing if there is nothing to do or a writing configuration + a set of reading configurations associated with file names.
readopt :: [String] -> Option
readopt [] = NoOption
readopt ("-h":xs) = Help
readopt ("-d":[]) = 
    Error $ ["Error: expected string after -d option."]
readopt ("-d":x:xs)
    | head x == '-' = readopt (x:xs) `cue` readopt ["-d"]
    | otherwise =
        readopt xs `chain` \cmd ->
            Cmd $ cmd { outputdir = x }
readopt ("-s":[]) = 
    Error $ ["Error: expected string after -s option."]
readopt ("-s":x:xs)
    | head x == '-' = readopt (x:xs) `cue` readopt ["-s"]
    | otherwise =
        readopt xs `chain` \cmd ->
            Cmd $ cmd { substitutionFiles = (substitutionFiles cmd) ++ [x] }
readopt (x:xs) =
    readopt xs `chain` \cmd ->
        if head x == '-' then
            case lookup (tail x) writeConfTable of
              Nothing -> Error ["Unknown writing configuration '" ++ x ++ "'"]
              Just wc' -> Cmd $ cmd { writeconf = wc' }
        else
            case lookup (ext x) readConfTable of
              Nothing -> Error ["Cannot find parser for file '" ++ x ++ "'"]
              Just rc -> Cmd $ cmd { readconfs = (x,rc):(readconfs cmd) }
    where ext = last . splitOn "."








