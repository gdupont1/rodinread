{-|
Module      : Main
Description : Main module for this project
Copyright   : (c) Guillaume Dupont, 2018
License     : MIT
Maintainer  : guillaume.dupont55@gmail.com

Main module, entry point.
-}
module Main where

import TeX
import Ascii
import System.Environment
import Control.Monad (forM_)
import RodinTheory (Theory)
import RodinTheory.Read
import RodinTheory.TeX
import RodinTheory.Ascii
import RodinContext (Context)
import RodinContext.Read
import RodinContext.TeX
import RodinContext.Ascii
import RodinMachine (Machine)
import RodinMachine.Read
import RodinMachine.TeX
import RodinMachine.Ascii
import RodinPO (POFile)
import RodinPO.Read
import RodinPO.TeX
--import RodinPO.Ascii
import Data.List (lookup)
import Data.List.Split (splitOn)

-- | Define a type as being "parsable"
-- This serves as a wrapper for defining parser configurations.
-- To properly add a parser, one should first create a new constructor in the Parsed data type,
-- then instanciate the resulting structure of its parser as being parsable.
class Parsable a where
  toParsed :: a -> Parsed

-- | A Context is parsable
instance Parsable Context where
  toParsed = PContext

-- | A Machine is parsable
instance Parsable Machine where
  toParsed = PMachine

-- | A Theory is parsable
instance Parsable Theory where
  toParsed = PTheory

instance Parsable POFile where
  toParsed = PPOFile

-- | Parsed data type, effectively wrapping the structures resulting from parsing.
-- When adding a parser, one should also add a constructor to this type that wraps her new structure.
data Parsed =
      PContext Context
    | PMachine Machine
    | PTheory  Theory
    | PPOFile  POFile

-- | Parsed can be ShowTeX; it comes from the fact that the objects in its constructors are effectively ShowTeX
-- If one want to be able to export its parsed structure to TeX, it should add the relevant line
instance ShowTeX Parsed where
  showTeX (PContext ct) = showTeX ct
  showTeX (PMachine ma) = showTeX ma
  showTeX (PTheory  th) = showTeX th
  showTeX (PPOFile  po) = showTeX po

-- | Same thing as for ShowTeX but for ASCII
instance ShowAscii Parsed where
  showAscii (PContext ct) = showAscii ct
  showAscii (PMachine ma) = showAscii ma
  showAscii (PTheory  th) = showAscii th
  showAscii (PPOFile  po) = "__unsupported__"

-- | Create a parser for a parsable object based on its actual parser.
-- This will basically take any parser of the form String -> IO a to a parser of the form String -> IO Parsed (effectively doing the wrapping).
mkParser :: Parsable a => (String -> IO a) -> (String -> IO Parsed)
mkParser parser =
    \x -> parser x >>= (return . toParsed)

-- | A read (or parsing) configuration.
data ReadConfig = ReadConfig {
    readerName :: String,               -- ^ Name of the parser (for pretty printing)
    processor  :: String -> IO Parsed   -- ^ The parsing function
}

-- | List of possible reading configurations as a (<file extension>,<reading configuration>) list
-- When adding a new parser, one should extend this table with correct informations.
readConfTable :: [(String,ReadConfig)]
readConfTable =
    [ ("buc",ReadConfig "context"           $ mkParser parseContextFile)
    , ("bum",ReadConfig "machine"           $ mkParser parseMachineFile)
    , ("tuf",ReadConfig "theory"            $ mkParser parseTheoryFile )
    , ("bpo",ReadConfig "proof obligations" $ mkParser parsePOFileFile) ]

-- | A write configuration
data WriteConfig = WriteConfig {
    writerName :: String,           -- ^ Writer name (for pretty printing)
    writerExtension :: String,      -- ^ File extension for the files generated by the writer
    stringify :: Parsed -> String   -- ^ Function turning a Parsed object to a proper string
}

-- | List of possible writing configurations as a (<file extension>,<writing configuration>) list
-- If one wants to add a new writer, it should create a typeclass for it and instanciate it for the various parsed structures.
-- It should then instanciate it for the Parsed type and add it to this table.
writeConfTable :: [(String,WriteConfig)]
writeConfTable = 
    [ (  "tex",WriteConfig "TeX" "tex" showTeX)
    , ("ascii",WriteConfig "ASCII" "ascii" showAscii) ]

-- | Default writing configuration (TeX)
defaultWriteConfig :: WriteConfig
defaultWriteConfig = WriteConfig "TeX" "tex" showTeX

-- | The main function.
-- Mainly read the options and do the processing
main :: IO ()
main = getArgs >>= readopt >>= \x ->
    case x of
      Nothing -> return ()
      Just (wc,rcs) -> forM_ rcs (\(fn,rc) -> process fn rc wc)

-- | Print help
printHelp :: IO ()
printHelp = do
    putStrLn "Rodin file transformer"
    putStrLn ""
    putStrLn "Syntax:"
    putStrLn "    program [-tex|-ascii] <file1> [<file2> [...]]"
    putStrLn ""
    putStrLn "Use -tex or -ascii to transform the given files in .tex or in .ascii (plain text)."
    putStrLn "Give the list of files; they will be combined in one big file. The program will"
    putStrLn "automatically determine the correct way to read it *based on its extension."
    putStrLn ""
    putStrLn "Supported extensions:"
    putStrLn "  Context description files (.buc)"
    putStrLn "  Machine description files (.bum)"
    putStrLn "  Theory description files (.tuf)"
    putStrLn ""

-- | Read the argument options and return either a Nothing if there is nothing to do or a writing configuration + a set of reading configurations associated with file names.
readopt :: [String] -> IO (Maybe (WriteConfig,[(String,ReadConfig)]))
readopt [] = return $ Just (defaultWriteConfig,[])
readopt (x:xs) =
    readopt xs >>= \pxs ->
        if x == "-h" then
            printHelp >> return Nothing
        else
            case pxs of
              Nothing -> return Nothing
              Just (wc,rcs) ->
                if head x == '-' then
                    case lookup (tail x) writeConfTable of
                      Nothing -> do
                          putStrLn $ "Unknown writing configuration '" ++ x ++ "'"
                          return $ Just (wc,rcs)
                      Just wc' -> return $ Just (wc',rcs)
                else
                    case lookup (ext x) readConfTable of
                      Nothing -> do
                          putStrLn $ "Cannot find parser for file '" ++ x ++ "'"
                          return $ Just (wc,rcs)
                      Just rc -> return $ Just (wc,(x,rc):rcs)
    where ext = last . splitOn "."

-- | Process a file with given reading and writing configuration
process :: String -> ReadConfig -> WriteConfig -> IO ()
process filename reader writer = do
    putStrLn $ "Parsing " ++ (readerName reader) ++ " file " ++ filename
    result <- processor reader filename
    putStrLn $ "Parsed!"
    putStrLn $ "Writing " ++ (writerName writer) ++ " file " ++ filename ++ "." ++ (writerExtension writer) ++ "..."
    writeFile (filename ++ "." ++ writerExtension writer) $ stringify writer result
    putStrLn $ "Done."


